<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Benchmarks: baseball data</title>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Baseball benchmarks}
-->

<h1>Benchmarks: baseball data</h1>

<p>The purpose of these benchmarks is to be as fair as possible, to help understand the relatively performance tradeoffs of the different approaches. If you think my implementation of base or data.table equivalents is suboptimal, please let me know better ways.</p>

<p>Also note that I consider any significant performance difference between <code>dt</code> and <code>dt_raw</code> to be a bug in dplyr: for individual operations there should be very little overhead to calling data.table via dplyr. However, data.table may be significantly faster when performing the same sequence of operations as dplyr. This is because currently dplyr uses an eager evaluation approach so the individual calls to <code>[.data.table</code> don&#39;t get as much information about the desired result as the single call to <code>[.data.table</code> would if you did it by hand.</p>

<p>Thanks go to Matt Dowle and Arun Srinivasan for their extensive feedback on these benchmarks.</p>

<h2>Data setup</h2>

<p>The following benchmarks explore the performance on a somewhat realistic example: the <code>Batting</code> dataset from the Lahman package. It contains 96600 records on the batting careers of 96600 players from 1871 to 2012.</p>

<p>The first code block defines two alternative backends for the Batting dataset. Grouping operations are performed inline in each benchmark. This represents the common scenario where you group the data and immediately use it.</p>

<pre><code class="r">batting_df &lt;- tbl_df(Batting)
batting_dt &lt;- tbl_dt(Batting)
</code></pre>

<h2>Summarise</h2>

<p>Compute the average number of at bats for each player:</p>

<pre><code class="r">microbenchmark(
  dplyr_df = batting_df %.% group_by(playerID) %.% summarise(ab = mean(AB)),
  dplyr_dt = batting_dt %.% group_by(playerID) %.% summarise(ab = mean(AB)),
  dt_raw =   batting_dt[, list(ab = mean(AB)), by = playerID],
  base =     tapply(batting_df$AB, batting_df$playerID, FUN = mean),
  times = 5
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min    lq median    uq   max neval
#&gt;  dplyr_df  17.5  18.4   18.4  19.3  20.3     5
#&gt;  dplyr_dt  66.9  67.1   69.3  80.6  81.3     5
#&gt;    dt_raw  19.4  19.8   20.7  22.1  25.6     5
#&gt;      base 183.8 186.9  194.9 212.5 216.5     5
</code></pre>

<p>NB: base implementation captures computation but not output format, giving considerably less output.</p>

<p>However, this comparison is slightly unfair because both data.table and <code>summarise()</code> use tricks to find a more efficient implementation of <code>mean()</code>. Data table calls a <code>C</code> implementation of the <code>mean (using</code>.External(Cfastmean, B, FALSE)<code>and thus avoiding the overhead of S3 method dispatch).</code>dplyr::summarise uses a hybrid evaluation technique, where common functions are implemented purely in C++, avoiding R function call overhead.</p>

<pre><code class="r">mean_ &lt;- function(x) .Internal(mean(x))
microbenchmark(
  dplyr_df = batting_df %.% group_by(playerID) %.% summarise(ab = mean_(AB)),
  dplyr_dt = batting_dt %.% group_by(playerID) %.% summarise(ab = mean_(AB)),
  dt_raw =   batting_dt[, list(ab = mean_(AB)), by = playerID],
  base =     tapply(batting_df$AB, batting_df$playerID, FUN = mean_),
  times = 5
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr  min   lq median   uq  max neval
#&gt;  dplyr_df 28.0 31.3   32.9 33.7 35.5     5
#&gt;  dplyr_dt 33.0 41.6   72.0 73.5 76.4     5
#&gt;    dt_raw 17.4 18.3   18.9 19.5 26.0     5
#&gt;      base 81.9 82.0   82.4 83.0 84.9     5
</code></pre>

<h2>Arrange</h2>

<p>Arrange by year within each player:</p>

<pre><code class="r">microbenchmark(
  dplyr_df = batting_df %.% arrange(playerID, yearID),
  dplyr_dt = batting_dt %.% arrange(playerID, yearID),
  dt_raw =   setkey(copy(batting_dt), playerID, yearID),
  base   =   batting_dt[order(batting_df$playerID, batting_df$yearID), ],
  times = 2
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min    lq median    uq   max neval
#&gt;  dplyr_df  10.2  10.2   11.3  12.4  12.4     2
#&gt;  dplyr_dt 187.1 187.1  203.4 219.8 219.8     2
#&gt;    dt_raw  17.4  17.4   18.0  18.6  18.6     2
#&gt;      base  69.7  69.7   85.9 102.1 102.1     2
</code></pre>

<h2>Filter</h2>

<p>Find the year for which each player played the most games:</p>

<pre><code class="r">microbenchmark(
  dplyr_df = batting_df %.% group_by(playerID) %.% filter(G == max(G)),
  dplyr_dt = batting_dt %.% group_by(playerID) %.% filter(G == max(G)),
  dt_raw   = batting_dt[batting_dt[, .I[G == max(G)], by = playerID]$V1],
  base   =   batting_df[ave(batting_df$G, batting_df$playerID, FUN = max) ==
    batting_df$G, ],
  times = 2
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min    lq median    uq   max neval
#&gt;  dplyr_df  45.2  45.2   47.0  48.8  48.8     2
#&gt;  dplyr_dt  49.4  49.4   52.9  56.5  56.5     2
#&gt;    dt_raw  37.4  37.4   38.4  39.4  39.4     2
#&gt;      base 111.8 111.8  112.1 112.3 112.3     2
</code></pre>

<p>I&#39;m not aware of a single line data table equivalent (<a href="http://stackoverflow.com/questions/16573995/">see SO 16573995</a>). Suggetions welcome.  dplyr currently doesn&#39;t support hybrid evaluation for logical comparison, but it is scheduled for 0.2 (see <a href="https://github.com/hadley/dplyr/issues/113">#113</a>), this should give an additional speed up.</p>

<h2>Mutate</h2>

<p>Rank years based on number of at bats:</p>

<pre><code class="r">microbenchmark(
  dplyr_df  = batting_df %.% group_by(playerID) %.% mutate(r = rank(desc(AB))),
  dplyr_dt  = batting_dt %.% group_by(playerID) %.% mutate(r = rank(desc(AB))),
  dt_raw =    copy(batting_dt)[, rank := rank(desc(AB)), by = playerID],
  times = 2
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr min  lq median  uq max neval
#&gt;  dplyr_df 631 631    645 659 659     2
#&gt;  dplyr_dt 680 680    693 705 705     2
#&gt;    dt_raw 601 601    602 603 603     2
</code></pre>

<p>(The <code>dt_raw</code> code needs to explicitly copy the data.table so the it doesn&#39;t modify in place, as is the data.table default. This is an example where it&#39;s difficult to compare data.table and dplyr directly because of different underlying philosophies.)</p>

<p>Compute year of career:</p>

<pre><code class="r">microbenchmark(
  dplyr_df = batting_df %.% group_by(playerID) %.%
    mutate(cyear = yearID - min(yearID) + 1),
  dplyr_dt = batting_dt %.% group_by(playerID) %.%
    mutate(cyear = yearID - min(yearID) + 1),
  dt_raw =   copy(batting_dt)[, cyear := yearID - min(yearID) + 1,
    by = playerID],
  times = 5
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr  min   lq median   uq   max neval
#&gt;  dplyr_df 48.3 49.5   50.5 51.0  51.7     5
#&gt;  dplyr_dt 63.7 65.8   92.5 93.1 131.2     5
#&gt;    dt_raw 23.7 26.3   29.0 63.4  66.2     5
</code></pre>

<p>Rank is a relatively expensive operation and <code>min()</code> is relatively cheap, showing the the relative performance overhead of the difference techniques.</p>

<p>dplyr currently has some support for hybrid evaluation of window functions. This yields substantial speed-ups where available:</p>

<pre><code class="r">min_rank_ &lt;- min_rank
microbenchmark(
  hybrid  = batting_df %.% group_by(playerID) %.% mutate(r = min_rank(AB)),
  regular  = batting_df %.% group_by(playerID) %.% mutate(r = min_rank_(AB)),
  times = 2
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;     expr   min    lq median    uq   max neval
#&gt;   hybrid  52.6  52.6   53.5  54.3  54.3     2
#&gt;  regular 648.7 648.7  651.7 654.8 654.8     2
</code></pre>

<h2>Joins</h2>

<p>We conclude with some quick comparisons of joins. First we create two new datasets: <code>master</code> which contains demographic information on each player, and <code>hall_of_fame</code> which contains all players inducted into the hall of fame.</p>

<pre><code class="r">master_df &lt;- tbl_df(Master) %.% select(playerID, hofID, birthYear)
hall_of_fame_df &lt;- tbl_df(HallOfFame) %.% filter(inducted == &quot;Y&quot;) %.%
  select(hofID, votedBy, category)

master_dt &lt;- tbl_dt(Master) %.% select(playerID, hofID, birthYear)
hall_of_fame_dt &lt;- tbl_dt(HallOfFame) %.% filter(inducted == &quot;Y&quot;) %.%
  select(hofID, votedBy, category)
</code></pre>

<pre><code class="r">microbenchmark(
  dplyr_df = left_join(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  dplyr_dt = left_join(master_dt, hall_of_fame_dt, by = &quot;hofID&quot;),
  base     = merge(master_df, hall_of_fame_df, by = &quot;hofID&quot;, all.x = TRUE),
  times = 10
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr    min    lq median    uq   max neval
#&gt;  dplyr_df  0.982  1.11   1.21  1.31  3.00    10
#&gt;  dplyr_dt  3.025  3.25   3.29  3.35  4.06    10
#&gt;      base 28.785 29.97  32.47 35.47 41.60    10
</code></pre>

<pre><code class="r">
microbenchmark(
  dplyr_df = inner_join(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  dplyr_dt = inner_join(master_dt, hall_of_fame_dt, by = &quot;hofID&quot;),
  base     = merge(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  times = 10
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min    lq median    uq  max neval
#&gt;  dplyr_df 0.876 0.887  0.943 0.958 1.03    10
#&gt;  dplyr_dt 2.063 2.106  2.240 2.423 3.12    10
#&gt;      base 2.112 2.345  2.542 2.647 2.94    10
</code></pre>

<pre><code class="r">
microbenchmark(
  dplyr_df = semi_join(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  dplyr_dt = semi_join(master_dt, hall_of_fame_dt, by = &quot;hofID&quot;),
  times = 10
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr  min    lq median    uq  max neval
#&gt;  dplyr_df 0.87 0.878  0.897 0.914 1.08    10
#&gt;  dplyr_dt 1.33 1.344  1.423 1.481 1.64    10
</code></pre>

<pre><code class="r">
microbenchmark(
  dplyr_df = anti_join(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  dplyr_dt = anti_join(master_dt, hall_of_fame_dt, by = &quot;hofID&quot;),
  times = 10
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr  min   lq median   uq  max neval
#&gt;  dplyr_df 1.21 1.39   1.43 1.48 1.52    10
#&gt;  dplyr_dt 2.32 2.71   2.82 3.00 3.50    10
</code></pre>

</body>

</html>
